# 1. Overview

This module implements a Cross-Chain Multi-user Wallet on the Sui blockchain using the Ika MPC (Multi-Party Computation) network.

Unlike traditional multi-sig wallets where multiple private keys authorize signing on-chain, this smart contract acts as an orchestrator. It manages user permissions via an RBAC (Role-Based Access Control) system and coordinates the signing of transactions for other blockchains (Bitcoin, Ethereum, Solana, etc.) without the private key ever being fully reconstructed.

Each wallet is set as a Shared Object on Sui, allowing concurrent interactions by multiple authorized users.

# 2. Architecture

The contract enables two main features each wallet should have: **Security** and **Cross-chain interoperability**.

- **RBAC (Role-Based Access Control)** → Security is managed through a granular role system:
  
  ```move
      public struct RoleConfig has store, copy, drop {

        sign_ability: bool,

        spending_limit: u64,

        recovery_time_ms: u64
    }
  ```
  - **Admin**: Has full control. Can add/remove users, modify role configurations, has no spending limits and can cancel recovery attempts.
  - **Users (custom roles)**: Through the Role Config type it is possible for a Wallet owner to create users with custom roles to have better control over wallet abilities and security.
    - **Signer** : has the ability to sign payment transactions under a specific amount decided by the admin 
    - **Custodian** : can just initialize recovery, can't sign

  The RoleConfig struct is extensible to let the admin decide the level of detail of a certain role (working on modularity for this).

- **Ika MPC (Multi-party computation)** → Multi-chain interoperability is enabled securely and natively by 2PC-MP, a dual share system (user share – Ika Network share):
  - **dWallets** : dWallets are the direct implementation of the MPC protocol, they are programmable and transferable signing mechanism with an address on any other blockchain, that can sign transactions to those networks:
    - **DKG (Distributed Key Generation)** : Upon create_wallet, a distributed key is generated. the secret shares of the dWallet are cryptographically and securely generated by the user and the network.
    - **Transaction Signing** : the user (holding a key share off-chain) collaborates with the network to generate a signature without ever reconstructing the full private key.
  
  Our wallet uses shared dWallets, the user's secret share is publicly stored on the network, creating a simplified trust model where the network has full access to both shares, which means you're trusting the network to operate correctly.
  
  The contract adds dWallet capabilities based on the curve they were created on. This model lets the user basically sign on most of chains just by adding a capability to the wallet.

  ```move
    dWallets
    ├── "secp256k1"   → DWalletCap
    ├── "secp256r1"   → DWalletCap  
    └── "ed25519" → DWalletCap
    ...
  ``` 
  
> [!WARNING]
> Generating a cryptographic signature via MPC involves complex mathematical computations and multiple rounds of network communication between Ika nodes. Doing this in real-time during a user transaction (sign_messagge) would be too slow (taking seconds or minutes) and expensive in terms of gas execution. Official SUI rpc node will probaly fail for the amount of requests. Be sure to use a RPC node supporting a sufficient amount of requests. To speed up the process even more the contract adopts presignatures pools

# 3. Key functionalities

- **INITIALIZATION**
  - **create_wallet** : initializes the shared wallet object, sets the creator as Admin, configures initial roles, and executes the first Distributed Key Generation (DKG) to create the first dWallet capability. Requires IKA and SUI coins to fund the wallet.
- **ADMIN MAINTENANCE**
  - **add_dWallet** : expands the wallet to support additional curves (e.g., adding Ed25519 for Solana support to an existing ECDSA wallet).
  - **add_presignature_to_pool** : it requests the Ika network to pre-calculate signature nonces and stores them in the contract based on thei pair curve-signature algorithm. This allows sign_messagge to execute faster later.
  - **add_users** : adds new addresses to the wallet and assigns them a specific Role ID.
  - **remove_users** : removes users. *Cannot remove all recovery users or the Admin*
  - **update_users_role** : promotes or demotes existing users by changing their Role ID.
  - **add roles** : add roles to the existing config
- **SOCIAL RECOVERY**
  - **init_recovery** : can be called by every user to propose a new Admin. Starts a time-lock based on the caller's role configuration.
  - **finalize_recovery** : executes the Admin change once the time-lock period has passed.
  - **cancel_recovery (Admin only)** : allows the current Admin to stop a pending recovery request (anti-malevolent mechanism).
- **INTERNAL HELPERS**
  - **withdraw/return payment_coins** : wraps the wallet's internal IKA/SUI balances into Coins for MPC payments and then returns unused change from MPC operations back to the wallet's internal balance
  - **random_session_identifier** : generates a unique session ID for Ika network operations using the current transaction context.

# 4. modules structure
```
└── rbac_wallet
    ├── Move.lock
    ├── Move.toml
    └── sources
        ├── constants.move
        ├── errors.move
        ├── events.move
        └── rbac.move

```
constants.move mainly manages curves, signature algorithms and hash schemes combinations to properly sign.

# 5. Security

- Security strenghts ✅
  - **Distributed Key Security (MPC)** : The private key effectively never exists in a single location. It is generated and used via a distributed protocol (Ika). Even if the Sui smart contract is compromised, an attacker cannot extract the private key because the contract only holds a capability (DWalletCap)
  - **Immutable Policy** : The security rules of RBAC are enforced by the Sui blockchain's consensus, not by a centralized backend server. An attacker cannot bypass the sign_ability check or the recovery_time_ms without compromising the Sui network itself
  - **Time-Locked Defense** : The recovery mechanism makes sure a potential key compromise can be a manageable event, even if the admin loses his keys there is still the possibility to recovery the wallet. The mandatory recovery_time_ms gives the legitimate Admin a window of time to detect a unauthorized recovery attempt and cancel it using cancel_recovery before funds are stolen.
- Security concerns ❌
  - **Admin as single point of failure** : The Admin has absolute control over roles configuration and users management. If the Admin's credentials are stolen the malevolent admin can cancel recoveries and sign transactions draining funds. This could be solved by implementing a multi sig approach or double admin
  - **Blind Signing of arbitrary bytes**: The contract strictly enforces who can sign, but not what they are signing. The sign_messagge function accepts a raw hash. A compromised user with sign_ability could technically sign a transaction draining all assets on the external chain, regardless of the spending_limit config, unless an off-chain oracle or on-chain parser is integrated to validate the transaction payload against the limit.

# 6. TODOs
adding a backend oracle to verify bytes to sign, adding a multi sig mechainsm or double admin, enforce security checks on inputs.
